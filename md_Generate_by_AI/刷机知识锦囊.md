

## ① **刷入对象作用强度对比**

### **1. boot.img**

* **作用**：传统的 Android 内核 + ramdisk。
* **修改方式**：Magisk 早期主要是直接修补 boot.img，把 root、模块加载能力注入 ramdisk。
* **强度**：

  * 修改了最核心的启动文件，风险中等。
  * 出错就可能导致 **直接卡 logo / 无限重启**，但通常另一个槽还能救机。

---

### **2. init\_boot.img**（Android 13+ 引入）

* **作用**：分离式 ramdisk，专门用于加载早期启动逻辑和 init 进程配置。
* **修改方式**：Magisk 在 Android 13+ 开始推荐修补 init\_boot.img，而不是 boot.img。
* **强度**：

  * 影响早期启动过程（比 boot 更靠前）。
  * 如果 init\_boot 崩溃，往往比 boot.img 崩溃更严重 → 可能导致 **system 没有机会 fallback**。
  * 风险比 boot.img 更高一些，但现代机型必须走这条路。

---

### **3. AnyKernel（MagiskBoot 内核补丁包）**

* **作用**：这是一个“打包器”，把编译好的内核（zImage/dtb/dtbo）和 ramdisk 补丁封装成一个 ZIP（卡刷包/fastboot 刷）。
* **特点**：

  * 不直接覆盖整个 boot/init\_boot，而是解包 → 替换 → 再打包，保留原始环境。
  * 比较“温和”，一般失败率低于直接覆盖。
* **强度**：

  * 比修补 boot/init\_boot 更灵活（因为能保留更多厂商 ramdisk 原始配置）。
  * 但仍然在 **内核级别**，属于高危修改。

---

✅ **推荐给普通用户的选择**

* **Root 需求 + 稳定性优先**：用 **Magisk 修补 init\_boot.img**（新机型） / boot.img（旧机型）。
* **内核调试 / 高阶玩法**：用 **AnyKernel**，因为它更适合内核开发者和 DIY 内核玩家。
* **不建议普通用户**：直接手动替换 boot/init\_boot.img → 容错率太低。

---

## ② **系统无限重启 / 崩溃 → 安全模式**

> 注意：你说的“init\_boot.img 模块形式崩溃”，其实就是 **Magisk 模块导致循环重启**。

1. **进入安全模式（官方 Android 功能）**

   * 方法：长按电源键 → 长按“关机” → 弹出“安全模式”提示 → 点击确认。
   * 结果：系统以“最小化配置”启动，第三方 APP 不加载（但 **Magisk 模块仍可能提前加载**）。

2. **Magisk 的专属“安全模式”**
   * 详细进入模式可查看对于官网说明，系列--[kernelsu](https://kernelsu.org/zh_CN/guide/rescue-from-bootloop.html)👈救砖。
   * 重启手机 → 出现厂商 Logo 时 → 快速按住 **音量减**。
   * 效果：跳过 **Magisk 模块加载**，系统仍然能正常进入。
   * 这样可以进入系统 → 打开 Magisk → 禁用/卸载出错的模块 → 重启。

👉 所以针对 **init\_boot.img 模块崩溃**，主要靠这个“**音量减跳过模块**”来救机。

---

## ③ **用户 adb 删除底层框架包 → 修复方式**

比如你提到的：

* `com.android.installer`（PackageInstaller）
* 甚至 SystemUI / SettingsProvider / 重要系统 app

一旦删除，会导致：

* 无法安装 APK
* 直接进入无限重启 / 黑屏

### **修复策略**

1. **如果还能进系统（但功能缺失）**

   * 直接把系统 APK（如 `PackageInstaller.apk`）推回去：

     ```bash
     adb push PackageInstaller.apk /system/priv-app/PackageInstaller/
     adb shell chmod 644 /system/priv-app/PackageInstaller/PackageInstaller.apk
     ```
   * 然后重启。

2. **如果系统直接崩溃 / 卡死**

   * 必须重新刷 **完整系统分区**，比如：

     * `system.img`
     * `system_ext.img`
     * `product.img`
     * `vendor.img`

   * 通常卡刷包 / 官方 OTA 包会包含这些分区，把它们刷回去即可恢复。

   
---

##  总结

1. **强度对比**：

   * boot.img → 中风险
   * init\_boot.img → 新机必选，风险略高
   * AnyKernel → 灵活但高级，适合内核玩家
     → 普通用户推荐用 **Magisk 修补 init\_boot.img**

2. **崩溃恢复**：

   * ~~无限重启 → 按住 **音量减** 跳过 Magisk 模块加载~~
   * 系统安全模式仅屏蔽三方 app，不解决 init\_boot 崩溃

3. **误删底层框架包**：

   * 轻微：推回 APK
   * 严重：必须重新刷 `system.img / product.img / system_ext.img` 等

⚠️ **关键点**：

* 误删 framework 层 app 不是单个 APK 就能恢复的，常常需要整块 system/product 镜像才能解决。
* 最保险的就是准备一个 **完整卡刷包** 或者 **官方 OTA**。

---

从 Android 10 开始，Google 引入了 **super 分区（super.img）** 来管理大分区：

* system
* system\_ext
* product
* vendor
* odm

这些不再是独立的物理分区，而是由 **super 分区里面逻辑切片**组成。
所以在 fastboot 里，你只能看到：

```
partition-type:super: raw
partition-size:super: 369000000
```

👉 也就是说，`system.img`、`vendor.img`、`product.img`、`system_ext.img` 都会被刷进 **super.img 里面**，而不是单独对应某个物理分区。

### 🔹 正确刷法（动态分区机型）

这种机型要用 **fastbootd** 模式来刷：

1. 进入 fastbootd：

   ```bash
   fastboot reboot fastboot
   ```

2. 在 fastbootd 下刷入：

   ```bash
   fastboot flash system system.img
   fastboot flash system_ext system_ext.img
   fastboot flash product product.img
   fastboot flash vendor vendor.img
   ```

⚠️ 注意：这里不用写 `_a` 或 `_b`，因为动态分区逻辑上是共享的，Google 把它们放在 super 分区里管理。
（slot 冗余主要还是 boot/init\_boot/vendor\_boot/vbmeta 等分区）

* 所以你要恢复系统时：

    * 进 fastbootd

    * 刷 system/product/vendor/system_ext 四大镜像

    * 再刷 boot/init_boot/vendor_boot 三件套（A/B 各自一份）


---

## **④ 个人认为重要**
* 手机变砖无限重启后，能进入fastboot模式，就尽快在fastboot模式救砖，特别是安全模式卸载模块或重刷img文件。不要进行任何数据擦除。
  * `system.img`
  * `system_ext.img`
  * `product.img`
  * `vendor.img`

* 相关清除数据命令（**在确保系统不会变砖，符合自己预期目的的条件下。不要随便动手机文件系统**）


**清除数据（恢复出厂 / 格式化）**，在 fastboot/fastbootd 下有几种常见方式。

---

### 🔹 1. 清空 **userdata**（用户数据分区）

这是最常见的“恢复出厂设置”：

```bash
fastboot erase userdata
```

👉 等价于刷 Recovery 里的 “清除数据/恢复出厂”。
会删除应用、账号、内部存储文件。

---

### 🔹 2. 清空 **cache**（缓存分区，部分机型已无）

```bash
fastboot erase cache
```

👉 有的机型已经取消了 `cache` 分区（因为 A/B 无缝更新用 `/data/cache` 代替了）。

---

### 🔹 3. 格式化（比 erase 更彻底）

```bash
fastboot format userdata
```

👉 `format` 会重新建立文件系统（比如 f2fs/ext4），适用于数据损坏、开机卡 logo。
（erase 只是清空头部信息，速度快；format 会慢一些，但更干净）

---

### 🔹 4. 动态分区机型（带 super）

有时刷完整包前，官方会要求清空 super 分区：

```bash
fastboot erase super
```

👉 一般只在 `super` 镜像损坏或强刷完整 ROM 时用。普通清数据 **不要碰 super**。

---

### 🔹 5. 组合操作（常见救砖流程）

如果你卡开机或想刷干净系统，可以：

```bash
fastboot erase userdata
fastboot erase metadata
fastboot erase cache   # 有就加上
```

其中 `metadata` 分区通常存储加密信息，刷机后不清它可能导致 **无限重启/加密解密失败**。

---

✅ **推荐做法（你的机型：天玑 + 动态分区 + Android 15）：**

```bash
fastboot erase userdata
fastboot erase metadata
fastboot format userdata
```

这样保证数据干净，避免因为加密残留导致进不去系统。

---
